Module['_crypto_aead_chacha20poly1305_ABYTES']                      = 16;
Module['_crypto_aead_chacha20poly1305_KEYBYTES']                    = 32;
Module['_crypto_aead_chacha20poly1305_NPUBBYTES']                   = 8;
Module['_crypto_aead_chacha20poly1305_NSECBYTES']                   = 0;
Module['_crypto_auth_hmacsha256_BYTES']                             = 32;
Module['_crypto_auth_hmacsha256_KEYBYTES']                          = 32;
Module['_crypto_auth_hmacsha512256_BYTES']                          = 32;
Module['_crypto_auth_hmacsha512256_KEYBYTES']                       = 32;
Module['_crypto_auth_hmacsha512_BYTES']                             = 64;
Module['_crypto_auth_hmacsha512_KEYBYTES']                          = 32;
Module['_crypto_auth_PRIMITIVE']                                    = "hmacsha512256";
Module['_crypto_box_curve25519xsalsa20poly1305_BEFORENMBYTES']      = 32;
Module['_crypto_box_curve25519xsalsa20poly1305_BOXZEROBYTES']       = 16;
Module['_crypto_box_curve25519xsalsa20poly1305_NONCEBYTES']         = 24;
Module['_crypto_box_curve25519xsalsa20poly1305_PUBLICKEYBYTES']     = 32;
Module['_crypto_box_curve25519xsalsa20poly1305_SECRETKEYBYTES']     = 32;
Module['_crypto_box_curve25519xsalsa20poly1305_SEEDBYTES']          = 32;
Module['_crypto_box_curve25519xsalsa20poly1305_ZEROBYTES']          = 32;
Module['_crypto_box_PRIMITIVE']                                     = "curve25519xsalsa20poly1305";
Module['_crypto_core_hsalsa20_CONSTBYTES']                          = 16;
Module['_crypto_core_hsalsa20_INPUTBYTES']                          = 16;
Module['_crypto_core_hsalsa20_KEYBYTES']                            = 32;
Module['_crypto_core_hsalsa20_OUTPUTBYTES']                         = 32;
Module['_crypto_core_salsa2012_CONSTBYTES']                         = 16;
Module['_crypto_core_salsa2012_INPUTBYTES']                         = 16;
Module['_crypto_core_salsa2012_KEYBYTES']                           = 32;
Module['_crypto_core_salsa2012_OUTPUTBYTES']                        = 64;
Module['_crypto_core_salsa208_CONSTBYTES']                          = 16;
Module['_crypto_core_salsa208_INPUTBYTES']                          = 16;
Module['_crypto_core_salsa208_KEYBYTES']                            = 32;
Module['_crypto_core_salsa208_OUTPUTBYTES']                         = 64;
Module['_crypto_core_salsa20_CONSTBYTES']                           = 16;
Module['_crypto_core_salsa20_INPUTBYTES']                           = 16;
Module['_crypto_core_salsa20_KEYBYTES']                             = 32;
Module['_crypto_core_salsa20_OUTPUTBYTES']                          = 64;
Module['_crypto_generichash_blake2b_BYTES']                         = 32;
Module['_crypto_generichash_blake2b_BYTES_MAX']                     = 64;
Module['_crypto_generichash_blake2b_BYTES_MIN']                     = 16;
Module['_crypto_generichash_blake2b_KEYBYTES']                      = 32;
Module['_crypto_generichash_blake2b_KEYBYTES_MAX']                  = 64;
Module['_crypto_generichash_blake2b_KEYBYTES_MIN']                  = 16;
Module['_crypto_generichash_blake2b_PERSONALBYTES']                 = 16;
Module['_crypto_generichash_blake2b_SALTBYTES']                     = 16;
Module['_crypto_generichash_PRIMITIVE']                             = "blake2b";
Module['_crypto_hash_PRIMITIVE']                                    = "sha512";
Module['_crypto_hash_sha256_BYTES']                                 = 32;
Module['_crypto_hash_sha512_BYTES']                                 = 64;
Module['_crypto_onetimeauth_poly1305_BYTES']                        = 16;
Module['_crypto_onetimeauth_poly1305_KEYBYTES']                     = 32;
Module['_crypto_onetimeauth_PRIMITIVE']                             = "poly1305";
Module['_crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_INTERACTIVE']  = 16777216;
Module['_crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_SENSITIVE']    = 1073741824;
Module['_crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_INTERACTIVE']  = 524288;
Module['_crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_SENSITIVE']    = 33554432;
Module['_crypto_pwhash_scryptsalsa208sha256_SALTBYTES']             = 32;
Module['_crypto_pwhash_scryptsalsa208sha256_STRBYTES']              = 102;
Module['_crypto_scalarmult_curve25519_BYTES']                       = 32;
Module['_crypto_scalarmult_curve25519_SCALARBYTES']                 = 32;
Module['_crypto_scalarmult_PRIMITIVE']                              = "curve25519";
Module['_crypto_secretbox_PRIMITIVE']                               = "xsalsa20poly1305";
Module['_crypto_secretbox_xsalsa20poly1305_BOXZEROBYTES']           = 16;
Module['_crypto_secretbox_xsalsa20poly1305_KEYBYTES']               = 32;
Module['_crypto_secretbox_xsalsa20poly1305_NONCEBYTES']             = 24;
Module['_crypto_secretbox_xsalsa20poly1305_ZEROBYTES']              = 32;
Module['_crypto_shorthash_PRIMITIVE']                               = "siphash24";
Module['_crypto_shorthash_siphash24_BYTES']                         = 8;
Module['_crypto_shorthash_siphash24_KEYBYTES']                      = 16;
Module['_crypto_sign_ed25519_BYTES']                                = 64;
Module['_crypto_sign_ed25519_PUBLICKEYBYTES']                       = 32;
Module['_crypto_sign_ed25519_SECRETKEYBYTES']                       = 64;
Module['_crypto_sign_ed25519_SEEDBYTES']                            = 32;
Module['_crypto_sign_edwards25519sha512batch_BYTES']                = 64;
Module['_crypto_sign_edwards25519sha512batch_PUBLICKEYBYTES']       = 32;
Module['_crypto_sign_edwards25519sha512batch_SECRETKEYBYTES']       = 64;
Module['_crypto_sign_PRIMITIVE']                                    = "ed25519";
Module['_crypto_stream_aes128ctr_BEFORENMBYTES']                    = 1408;
Module['_crypto_stream_aes128ctr_KEYBYTES']                         = 16;
Module['_crypto_stream_aes128ctr_NONCEBYTES']                       = 16;
Module['_crypto_stream_aes256estream_BEFORENMBYTES']                = 276;
Module['_crypto_stream_aes256estream_KEYBYTES']                     = 32;
Module['_crypto_stream_aes256estream_NONCEBYTES']                   = 16;
Module['_crypto_stream_chacha20_KEYBYTES']                          = 32;
Module['_crypto_stream_chacha20_NONCEBYTES']                        = 8;
Module['_crypto_stream_PRIMITIVE']                                  = "xsalsa20";
Module['_crypto_stream_salsa2012_KEYBYTES']                         = 32;
Module['_crypto_stream_salsa2012_NONCEBYTES']                       = 8;
Module['_crypto_stream_salsa208_KEYBYTES']                          = 32;
Module['_crypto_stream_salsa208_NONCEBYTES']                        = 8;
Module['_crypto_stream_salsa20_KEYBYTES']                           = 32;
Module['_crypto_stream_salsa20_NONCEBYTES']                         = 8;
Module['_crypto_stream_xsalsa20_KEYBYTES']                          = 32;
Module['_crypto_stream_xsalsa20_NONCEBYTES']                        = 24;
Module['_crypto_verify_16_BYTES']                                   = 16;
Module['_crypto_verify_32_BYTES']                                   = 32;
Module['_crypto_verify_64_BYTES']                                   = 64;
Module['_SODIUM_LIBRARY_VERSION_MAJOR']                             = 6;
Module['_SODIUM_LIBRARY_VERSION_MINOR']                             = 0;


// NO ESTAN TOTES LES FUNCIONS
Module['_crypto_hash_BYTES']             = Module['_crypto_hash_sha512_BYTES'];
Module['_crypto_sign']                   = Module['_crypto_sign_ed25519'];
Module['_crypto_stream_xor_afternm']     = Module['_crypto_stream_xsalsa20_xor_afternm'];
Module['_crypto_box_PUBLICKEYBYTES']     = Module['_crypto_box_curve25519xsalsa20poly1305_PUBLICKEYBYTES'];
Module['_crypto_box_SECRETKEYBYTES']     = Module['_crypto_box_curve25519xsalsa20poly1305_SECRETKEYBYTES'];
Module['_crypto_box_open_afternm']       = Module['_crypto_box_curve25519xsalsa20poly1305_open_afternm'];
Module['_crypto_sign_SECRETKEYBYTES']    = Module['_crypto_sign_ed25519_SECRETKEYBYTES'];
Module['_crypto_box_beforenm']           = Module['_crypto_box_curve25519xsalsa20poly1305_beforenm'];
Module['_crypto_secretbox']              = Module['_crypto_secretbox_xsalsa20poly1305'];
Module['_crypto_hash']                   = Module['_crypto_hash_sha512'];
Module['_crypto_sign_PUBLICKEYBYTES']    = Module['_crypto_sign_ed25519_PUBLICKEYBYTES'];
Module['_crypto_stream_xor']             = Module['_crypto_stream_xor'];
Module['_crypto_generichash']            = Module['_crypto_generichash'];
Module['_crypto_box']                    = Module['_crypto_box_curve25519xsalsa20poly1305'];
Module['_crypto_secretbox_ZEROBYTES']    = Module['_crypto_secretbox_xsalsa20poly1305_ZEROBYTES'];
Module['_crypto_box_ZEROBYTES']          = Module['_crypto_box_curve25519xsalsa20poly1305_ZEROBYTES'];
Module['_crypto_secretbox_KEYBYTES']     = Module['_crypto_secretbox_xsalsa20poly1305_KEYBYTES'];
Module['_crypto_stream_beforenm']        = Module['_crypto_stream_xsalsa20_beforenm'];
Module['_crypto_onetimeauth_verify']     = Module['_crypto_onetimeauth_poly1305_verify'];
Module['_crypto_box_BOXZEROBYTES']       = Module['_crypto_box_curve25519xsalsa20poly1305_BOXZEROBYTES'];
Module['_crypto_hashblocks']             = Module['_crypto_hashblocks_sha512'];
Module['_crypto_stream']                 = Module['_crypto_stream_xsalsa20'];
Module['_crypto_onetimeauth_KEYBYTES']   = Module['_crypto_onetimeauth_poly1305_KEYBYTES'];
Module['_crypto_box_afternm']            = Module['_crypto_box_curve25519xsalsa20poly1305_afternm'];
Module['_crypto_secretbox_BOXZEROBYTES'] = Module['_crypto_secretbox_xsalsa20poly1305_BOXZEROBYTES'];
Module['_crypto_hashblocks_BLOCKBYTES']  = Module['_crypto_hashblocks_sha512_BLOCKBYTES'];
Module['_crypto_box_keypair']            = Module['_crypto_box_curve25519xsalsa20poly1305_keypair'];
Module['_crypto_auth']                   = Module['_crypto_auth_hmacsha512256'];
Module['_crypto_box_BEFORENMBYTES']      = Module['_crypto_box_curve25519xsalsa20poly1305_BEFORENMBYTES'];
Module['_crypto_secretbox_NONCEBYTES']   = Module['_crypto_secretbox_xsalsa20poly1305_NONCEBYTES'];
Module['_crypto_stream_KEYBYTES']        = Module['_crypto_stream_xsalsa20_KEYBYTES'];
Module['_crypto_box_NONCEBYTES']         = Module['_crypto_box_curve25519xsalsa20poly1305_NONCEBYTES'];
Module['_crypto_auth_verify']            = Module['_crypto_auth_hmacsha512256_verify'];
Module['_crypto_secretbox_open']         = Module['_crypto_secretbox_xsalsa20poly1305_open'];
Module['_crypto_sign_BYTES']             = Module['_crypto_sign_ed25519_BYTES'];
Module['_crypto_hashblocks_STATEBYTES']  = Module['_crypto_hashblocks_sha512_STATEBYTES'];
Module['_crypto_auth_BYTES']             = Module['_crypto_auth_hmacsha512256_BYTES'];
Module['_crypto_stream_BEFORENMBYTES']   = Module['_crypto_stream_xsalsa20_BEFORENMBYTES'];
Module['_crypto_auth_KEYBYTES']          = Module['_crypto_auth_hmacsha512256_KEYBYTES'];
Module['_crypto_stream_afternm']         = Module['_crypto_stream_xsalsa20_afternm'];
Module['_crypto_sign_keypair']           = Module['_crypto_sign_ed25519_keypair'];
Module['_crypto_onetimeauth_BYTES']      = Module['_crypto_onetimeauth_poly1305_BYTES'];
Module['_crypto_box_open']               = Module['_crypto_box_curve25519xsalsa20poly1305_open'];
Module['_crypto_stream_NONCEBYTES']      = Module['_crypto_stream_xsalsa20_NONCEBYTES'];
Module['_crypto_onetimeauth']            = Module['_crypto_onetimeauth_poly1305'];


var libsodium = (function () {
  'use strict';
  var exports = {};

  //---------------------------------------------------------------------------
  // Horrifying UTF-8 and hex codecs

  function encode_utf8( s ) {
      return encode_latin1( unescape( encodeURIComponent( s ) ) );
  }

  function encode_latin1( s ) {
      var result = new Uint8Array( s.length );
      for ( var i = 0; i < s.length; i++ ) {
          var c = s.charCodeAt( i );
          if ( (c & 0xff) !== c ) {
              throw {message: "Cannot encode string in Latin1", str: s};
          }
          result[i] = (c & 0xff);
      }
      return result;
  }

  function decode_utf8( bs ) {
      return decodeURIComponent( escape( decode_latin1( bs ) ) );
  }

  function decode_latin1( bs ) {
      var encoded = [];
      for ( var i = 0; i < bs.length; i++ ) {
          encoded.push( String.fromCharCode( bs[i] ) );
      }
      return encoded.join( '' );
  }

  function to_hex( bs ) {
      var encoded = [];
      for ( var i = 0; i < bs.length; i++ ) {
          encoded.push( "0123456789abcdef"[(bs[i] >> 4) & 15] );
          encoded.push( "0123456789abcdef"[bs[i] & 15] );
      }
      return encoded.join( '' );
  }

  function from_hex( s ) {
      var result = new Uint8Array( s.length / 2 );
      for ( var i = 0; i < s.length / 2; i++ ) {
          result[i] = parseInt( s.substr( 2 * i, 2 ), 16 );
      }
      return result;
  }

  //---------------------------------------------------------------------------
  // Allocation

  function MALLOC( nbytes ) {
      var result = libsodium_raw._malloc( nbytes );
      if ( result === 0 ) {
          throw {message: "malloc() failed", nbytes: nbytes};
      }
      return result;
  }

  function FREE( pointer ) {
      libsodium_raw._free( pointer );
  }

  //---------------------------------------------------------------------------

  function injectBytes( bs, leftPadding ) {
      var p = leftPadding || 0;
      var address = MALLOC( bs.length + p );
      libsodium_raw.HEAPU8.set( bs, address + p );
      for ( var i = address; i < address + p; i++ ) {
          libsodium_raw.HEAPU8[i] = 0;
      }
      return address;
  }

  function check_injectBytes( function_name, what, thing, expected_length, leftPadding ) {
      check_length( function_name, what, thing, expected_length );
      return injectBytes( thing, leftPadding );
  }

  function extractBytes( address, length ) {
      var result = new Uint8Array( length );
      result.set( libsodium_raw.HEAPU8.subarray( address, address + length ) );
      return result;
  }

  //---------------------------------------------------------------------------

  function check( function_name, result ) {
      if ( result !== 0 ) {
          throw {message: "libsodium_raw." + function_name + " signalled an error"};
      }
  }

  function check_length( function_name, what, thing, expected_length ) {
      if ( thing.length !== expected_length ) {
          throw {message: "libsodium." + function_name + " expected " +
                          expected_length + "-byte " + what + " but got length " + thing.length};
      }
  }

  function Target( length ) {
      this.length = length;
      this.address = MALLOC( length );
  }

  Target.prototype.extractBytes = function ( offset ) {
      var result = extractBytes( this.address + (offset || 0), this.length - (offset || 0) );
      FREE( this.address );
      this.address = null;
      return result;
  };

  function free_all( addresses ) {
      for ( var i = 0; i < addresses.length; i++ ) {
          FREE( addresses[i] );
      }
  }

  //---------------------------------------------------------------------------
  // Boxing

  function crypto_box_keypair() {
      var pk = new Target( libsodium_raw._crypto_box_PUBLICKEYBYTES );
      var sk = new Target( libsodium_raw._crypto_box_SECRETKEYBYTES );
      check( "_crypto_box_keypair", libsodium_raw._crypto_box_keypair( pk.address, sk.address ) );
      return {boxPk: pk.extractBytes(), boxSk: sk.extractBytes()};
  }

  function crypto_box_random_nonce() {
      return libsodium_raw.RandomBytes.crypto.randomBytes( libsodium_raw._crypto_box_NONCEBYTES );
  }

  function crypto_box( msg, nonce, pk, sk ) {
      var m   = injectBytes( msg, libsodium_raw._crypto_box_ZEROBYTES );
      var na  = check_injectBytes( "crypto_box", "nonce", nonce, libsodium_raw._crypto_box_NONCEBYTES );
      var pka = check_injectBytes( "crypto_box", "pk", pk, libsodium_raw._crypto_box_PUBLICKEYBYTES );
      var ska = check_injectBytes( "crypto_box", "sk", sk, libsodium_raw._crypto_box_SECRETKEYBYTES );
      var c   = new Target( msg.length + libsodium_raw._crypto_box_ZEROBYTES );
      check( "_crypto_box", libsodium_raw._crypto_box( c.address, m, c.length, 0, na, pka, ska ) );
      free_all( [m, na, pka, ska] );
      return c.extractBytes( libsodium_raw._crypto_box_BOXZEROBYTES );
  }

  function crypto_box_open( ciphertext, nonce, pk, sk ) {
      var c   = injectBytes( ciphertext, libsodium_raw._crypto_box_BOXZEROBYTES );
      var na  = check_injectBytes( "crypto_box_open", "nonce", nonce, libsodium_raw._crypto_box_NONCEBYTES );
      var pka = check_injectBytes( "crypto_box_open", "pk",    pk,    libsodium_raw._crypto_box_PUBLICKEYBYTES );
      var ska = check_injectBytes( "crypto_box_open", "sk",    sk,    libsodium_raw._crypto_box_SECRETKEYBYTES );
      var m   = new Target( ciphertext.length + libsodium_raw._crypto_box_BOXZEROBYTES );
      check( "_crypto_box_open", libsodium_raw._crypto_box_open( m.address, c, m.length, 0, na, pka, ska ) );
      free_all( [c, na, pka, ska] );
      return m.extractBytes( libsodium_raw._crypto_box_ZEROBYTES );
  }

  function crypto_box_precompute( pk, sk ) {
      var pka = check_injectBytes( "crypto_box_precompute",
                                   "pk", pk, libsodium_raw._crypto_box_PUBLICKEYBYTES );
      var ska = check_injectBytes( "crypto_box_precompute",
                                   "sk", sk, libsodium_raw._crypto_box_SECRETKEYBYTES );
      var k = new Target( libsodium_raw._crypto_box_BEFORENMBYTES );
      check( "_crypto_box_beforenm",
             libsodium_raw._crypto_box_beforenm( k.address, pka, ska ) );
      free_all( [pka, ska] );
      return {boxK: k.extractBytes()};
  }

  function crypto_box_precomputed( msg, nonce, state ) {
      var m = injectBytes( msg, libsodium_raw._crypto_box_ZEROBYTES );
      var na = check_injectBytes( "crypto_box_precomputed",
                                  "nonce", nonce, libsodium_raw._crypto_box_NONCEBYTES );
      var ka = check_injectBytes( "crypto_box_precomputed",
                                  "boxK", state.boxK, libsodium_raw._crypto_box_BEFORENMBYTES );
      var c = new Target( msg.length + libsodium_raw._crypto_box_ZEROBYTES );
      check( "_crypto_box_afternm",
             libsodium_raw._crypto_box_afternm( c.address, m, c.length, 0, na, ka ) );
      free_all( [m, na, ka] );
      return c.extractBytes( libsodium_raw._crypto_box_BOXZEROBYTES );
  }

  function crypto_box_open_precomputed( ciphertext, nonce, state ) {
      var c = injectBytes( ciphertext, libsodium_raw._crypto_box_BOXZEROBYTES );
      var na = check_injectBytes( "crypto_box_open_precomputed",
                                  "nonce", nonce, libsodium_raw._crypto_box_NONCEBYTES );
      var ka = check_injectBytes( "crypto_box_open_precomputed",
                                  "boxK", state.boxK, libsodium_raw._crypto_box_BEFORENMBYTES );
      var m = new Target( ciphertext.length + libsodium_raw._crypto_box_BOXZEROBYTES );
      check( "_crypto_box_open_afternm",
             libsodium_raw._crypto_box_open_afternm( m.address, c, m.length, 0, na, ka ) );
      free_all( [c, na, ka] );
      return m.extractBytes( libsodium_raw._crypto_box_ZEROBYTES );
  }

  //---------------------------------------------------------------------------
  // Hashing

  function crypto_hash( bs ) {
      var address = injectBytes( bs );
      var hash = new Target( libsodium_raw._crypto_hash_BYTES );
      check( "_crypto_hash", libsodium_raw._crypto_hash( hash.address, address, bs.length, 0 ) );
      FREE( address );
      return hash.extractBytes();
  }

  function crypto_hash_sha256( bs ) {
      var address = injectBytes( bs );
      var hash = new Target( libsodium_raw._crypto_hash_sha256_BYTES );
      check( "_crypto_hash_sha256",
             libsodium_raw._crypto_hash_sha256( hash.address, address, bs.length, 0 ) );
      FREE( address );
      return hash.extractBytes();
  }

  function crypto_hash_string( s ) {
      return crypto_hash( encode_utf8( s ) );
  }
  
  
  
  function crypto_generichash( outlen, input, key ) {
      var the_input = injectBytes( input );
      var the_key   = injectBytes( input );
      var the_out   = new Target( outlen );
                                                 //crypto_generichash(unsigned char *out, size_t outlen, const unsigned char *in, unsigned long long inlen, const unsigned char *key, size_t keylen);
                                                 //crypto_generichash(              $out,       $outlen,                     $in,                    $0,$1,                     $key,        $keylen) 
      check( "_crypto_generichash", libsodium_raw._crypto_generichash(   the_out.address,        outlen,               the_input,      0, the_input.length,                  the_key, the_key.length));
      free_all( [the_key, the_input] );
      return the_out.extractBytes();
  }
  
  //int crypto_generichash_init(crypto_generichash_state *state,
                            //const unsigned char *key,
                            //const size_t keylen, const size_t outlen);
  ////int crypto_generichash_init(crypto_generichash_state *state, const unsigned char *key, const size_t keylen, const size_t outlen);
  
  
  //int crypto_generichash_update(crypto_generichash_state *state,
                              //const unsigned char *in,
                              //unsigned long long inlen);
  ////int crypto_generichash_update(crypto_generichash_state *state, const unsigned char *in, unsigned long long inlen);
  
  
  
  //int crypto_generichash_final(crypto_generichash_state *state,
                             //unsigned char *out, const size_t outlen);
  ////int crypto_generichash_final(crypto_generichash_state *state, unsigned char *out, const size_t outlen);
  
  

  //---------------------------------------------------------------------------
  // Symmetric-key encryption

    function crypto_stream_random_nonce() {
        return libsodium_raw.RandomBytes.crypto.randomBytes( libsodium_raw._crypto_stream_NONCEBYTES );
    }

    function crypto_stream( len, nonce, key ) {
        var na = check_injectBytes( "crypto_stream", "nonce", nonce, libsodium_raw._crypto_stream_NONCEBYTES );
        var ka = check_injectBytes( "crypto_stream", "key", key, libsodium_raw._crypto_stream_KEYBYTES );
        var out = new Target( len );
        check( "_crypto_stream", libsodium_raw._crypto_stream( out.address, len, 0, na, ka ) );
        free_all( [na, ka] );
        return out.extractBytes();
    }

    function crypto_stream_xor(msg, nonce, key) {
        var na = check_injectBytes("crypto_stream_xor", "nonce", nonce, libsodium_raw._crypto_stream_NONCEBYTES);
        var ka = check_injectBytes("crypto_stream_xor", "key", key, libsodium_raw._crypto_stream_KEYBYTES);
        var ma = injectBytes(msg);
        var out = new Target(msg.length);
        check("_crypto_stream_xor", libsodium_raw._crypto_stream_xor(out.address, ma, msg.length, 0, na, ka));
        free_all([na, ka, ma]);
        return out.extractBytes();
    }



  //---------------------------------------------------------------------------
  // One-time authentication

  function crypto_onetimeauth( msg, key ) {
      var ka = check_injectBytes( "crypto_onetimeauth",
                                  "key", key, libsodium_raw._crypto_onetimeauth_KEYBYTES );
      var ma = injectBytes( msg );
      var authenticator = new Target( libsodium_raw._crypto_onetimeauth_BYTES );
      check( "_crypto_onetimeauth",
             libsodium_raw._crypto_onetimeauth( authenticator.address, ma, msg.length, 0, ka ) );
      free_all( [ka, ma] );
      return authenticator.extractBytes();
  }

  function crypto_onetimeauth_verify( authenticator, msg, key ) {
      if ( authenticator.length != libsodium_raw._crypto_onetimeauth_BYTES ) {
          return false;
      }
      var ka = check_injectBytes( "crypto_onetimeauth_verify",
                                  "key", key, libsodium_raw._crypto_onetimeauth_KEYBYTES );
      var ma = injectBytes( msg );
      var aa = injectBytes( authenticator );
      var result = libsodium_raw._crypto_onetimeauth_verify( aa, ma, msg.length, 0, ka );
      free_all( [ka, ma, aa] );
      return (result == 0);
  }

  //---------------------------------------------------------------------------
  // Authentication

  function crypto_auth( msg, key ) {
      var ka = check_injectBytes( "crypto_auth", "key", key, libsodium_raw._crypto_auth_KEYBYTES );
      var ma = injectBytes( msg );
      var authenticator = new Target( libsodium_raw._crypto_auth_BYTES );
      check( "_crypto_auth", libsodium_raw._crypto_auth( authenticator.address, ma, msg.length, 0, ka ) );
      free_all( [ka, ma] );
      return authenticator.extractBytes();
  }


  //function _crypto_auth($out,$in,$0,$1,$k) {
  //check( "_crypto_auth", libsodium_raw._crypto_auth( authenticator.address, ma, msg.length, 0, ka ) );

  function crypto_auth_verify( authenticator, msg, key ) {
      if ( authenticator.length != libsodium_raw._crypto_auth_BYTES ) {
          return false;
      }
      var ka = check_injectBytes( "crypto_auth_verify",
                                  "key", key, libsodium_raw._crypto_auth_KEYBYTES );
      var ma = injectBytes( msg );
      var aa = injectBytes( authenticator );
      var result = libsodium_raw._crypto_auth_verify( aa, ma, msg.length, 0, ka );
      free_all( [ka, ma, aa] );
      return (result == 0);
  }

  //---------------------------------------------------------------------------
  // Authenticated symmetric-key encryption

  function crypto_secretbox_random_nonce() {
      return libsodium_raw.RandomBytes.crypto.randomBytes( libsodium_raw._crypto_secretbox_NONCEBYTES );
  }

  function crypto_secretbox( msg, nonce, key ) {
      var m = injectBytes( msg, libsodium_raw._crypto_secretbox_ZEROBYTES );
      var na = check_injectBytes( "crypto_secretbox",
                                  "nonce", nonce, libsodium_raw._crypto_secretbox_NONCEBYTES );
      var ka = check_injectBytes( "crypto_secretbox",
                                  "key", key, libsodium_raw._crypto_secretbox_KEYBYTES );
      var c = new Target( msg.length + libsodium_raw._crypto_secretbox_ZEROBYTES );
      check( "_crypto_secretbox", libsodium_raw._crypto_secretbox( c.address, m, c.length, 0, na, ka ) );
      free_all( [m, na, ka] );
      return c.extractBytes( libsodium_raw._crypto_secretbox_BOXZEROBYTES );
  }

  function crypto_secretbox_open( ciphertext, nonce, key ) {
      var c = injectBytes( ciphertext, libsodium_raw._crypto_secretbox_BOXZEROBYTES );
      var na = check_injectBytes( "crypto_secretbox_open",
                                  "nonce", nonce, libsodium_raw._crypto_secretbox_NONCEBYTES );
      var ka = check_injectBytes( "crypto_secretbox_open",
                                  "key", key, libsodium_raw._crypto_secretbox_KEYBYTES );
      var m = new Target( ciphertext.length + libsodium_raw._crypto_secretbox_BOXZEROBYTES );
      check( "_crypto_secretbox_open",
             libsodium_raw._crypto_secretbox_open( m.address, c, m.length, 0, na, ka ) );
      free_all( [c, na, ka] );
      return m.extractBytes( libsodium_raw._crypto_secretbox_ZEROBYTES );
  }

  //---------------------------------------------------------------------------
  // Signing

  function crypto_sign_keypair() {
      var pk = new Target( libsodium_raw._crypto_sign_PUBLICKEYBYTES );
      var sk = new Target( libsodium_raw._crypto_sign_SECRETKEYBYTES );
      check( "_crypto_sign_keypair", libsodium_raw._crypto_sign_keypair( pk.address, sk.address ) );
      return {signPk: pk.extractBytes(), signSk: sk.extractBytes()};
  }

  function crypto_sign( msg, sk ) {
      var ma = injectBytes( msg );
      var ska = check_injectBytes( "crypto_sign", "sk", sk, libsodium_raw._crypto_sign_SECRETKEYBYTES );
      var sm = new Target( msg.length + libsodium_raw._crypto_sign_BYTES );
      var smlen = new Target( 8 );
      check( "_crypto_sign",
             libsodium_raw._crypto_sign( sm.address, smlen.address, ma, msg.length, 0, ska ) );
      free_all( [ma, ska] );
      sm.length = libsodium_raw.HEAPU32[smlen.address >> 2];
      FREE( smlen.address );
      return sm.extractBytes();
  }

  function crypto_sign_detached( msg, sk ) {
      // WARNING: Experimental. Works for ed25519 but not necessarily other implementations.
      var signed_msg = crypto_sign( msg, sk );
      return signed_msg.subarray( 0, libsodium_raw._crypto_sign_BYTES );
  }

  function crypto_sign_verify_detached( detached_signature, msg, pk ) {
      // WARNING: Experimental. Works for ed25519 but not necessarily other implementations.
      var signed_msg = new Uint8Array( detached_signature.length + msg.length );
      signed_msg.set( detached_signature, 0 );
      signed_msg.set( msg, detached_signature.length );
      return crypto_sign_open( signed_msg, pk ) !== null;
  }

  function crypto_sign_open( sm, pk ) {
      var sma = injectBytes( sm );
      var pka = check_injectBytes( "crypto_sign_open",
                                   "pk", pk, libsodium_raw._crypto_sign_PUBLICKEYBYTES );
      var m = new Target( sm.length );
      var mlen = new Target( 8 );
      if ( libsodium_raw._crypto_sign_open( m.address, mlen.address, sma, sm.length, 0, pka ) === 0 ) {
          free_all( [sma, pka] );
          m.length = libsodium_raw.HEAPU32[mlen.address >> 2];
          FREE( mlen.address );
          return m.extractBytes();
      }
      else {
          free_all( [sma, pka, m.address, mlen.address] );
          return null;
      }
  }

  //---------------------------------------------------------------------------
  // Keys

  // Canviar a: crypto_sign_seed_keypair
  function crypto_sign_keypair_from_seed( bs ) {
      //var seeda = check_injectBytes( "crypto_sign_seed_keypair", "seed", bs, libsodium_raw._crypto_sign_SECRETKEYBYTES / 2 );
      
      var hash = new Uint8Array( crypto_hash( bs ) );
      hash = hash.subarray( 0, libsodium_raw._crypto_sign_SECRETKEYBYTES / 2 )
      var pk = new Target( libsodium_raw._crypto_sign_PUBLICKEYBYTES );
      var sk = new Target( libsodium_raw._crypto_sign_SECRETKEYBYTES );
      check( "_crypto_sign_seed_keypair", libsodium_raw._crypto_sign_seed_keypair( pk.address, sk.address, hash ) );
      FREE( hash );
      return {signPk: pk.extractBytes(), signSk: sk.extractBytes()};
  }

  function crypto_box_keypair_from_seed( bs ) {
    var hash = new Uint8Array( crypto_hash( bs ) );
    hash = hash.subarray( 0, libsodium_raw._crypto_box_SECRETKEYBYTES )
    return crypto_box_keypair_from_raw_sk( hash );
  }

  function crypto_box_keypair_from_raw_sk( sk ) {
      return {boxPk: crypto_scalarmult_base( sk ), boxSk: sk};
  }

  //---------------------------------------------------------------------------
  // Scalarmult

  function crypto_scalarmult( n, p ) {
      var na = check_injectBytes( "crypto_scalarmult", "n", n,
                                  libsodium_raw._crypto_scalarmult_curve25519_SCALARBYTES );
      var pa = check_injectBytes( "crypto_scalarmult", "p", p,
                                  libsodium_raw._crypto_scalarmult_curve25519_BYTES );
      var q = new Target( libsodium_raw._crypto_scalarmult_curve25519_BYTES );
      check( "_crypto_scalarmult_curve25519",
             libsodium_raw._crypto_scalarmult_curve25519( q.address, na, pa ) );
      FREE( na );
      FREE( pa );
      return q.extractBytes();
  }

  function crypto_scalarmult_base( n ) {
      var na = check_injectBytes( "crypto_scalarmult_base", "n", n,
                                  libsodium_raw._crypto_scalarmult_curve25519_SCALARBYTES );
      var q = new Target( libsodium_raw._crypto_scalarmult_curve25519_BYTES );
      check( "_crypto_scalarmult_curve25519_base",
             libsodium_raw._crypto_scalarmult_curve25519_base( q.address, na ) );
      FREE( na );
      return q.extractBytes();
  }

  //---------------------------------------------------------------------------
  
  // Scrypt
  
  /*
  Yes, you have to create your own function first in order to, after, be easy to use:
  1.- Find the function on the libsodium.js code [use vim find, grep command...  who cares ;) ]
      Ex.: "crypto_pwhash_scryptsalsa208sha256_ll" -- find --> function _crypto_pwhash_scryptsalsa208sha256_ll($passwd,$passwdlen,$salt,$saltlen,$0,$1,$r,$p,$buf,$buflen) {
      The found function it the function we have to use:
  2.- The parameters:
      The input strings that has to be passed to the function have to be passed first for encode_utf8, so we obtain a
                bit array, and after that we have to use injectBytes.
      The input numbers that has to be passed to the function can be passed normally.
      The output strings have to be declared through new Target( <variable name> ); and they have to be based using the
                internal pointer to be altered by the library (<variable name>.address)
     
      WARNING!!!
      When a C function use uint64_t, the emcc cut the variable to two of uint32_t, so some times (like this case)
      you will find more parameters than on the C code.
      The variable you have to set it's the $0 one, the rest can be set to 0.
     
  */
 
  function crypto_pwhash_scryptsalsa208sha256_ll(password, salt, N, r, p, olen){
    
    var password_byte = injectBytes( encode_utf8(password) );
    var salt_byte     = injectBytes( encode_utf8(salt) );
    var password_leng = encode_utf8(password).length;
    var salt_leng     = encode_utf8(salt).length;
    var data_byte     = new Target( olen );

    //function    _crypto_pwhash_scryptsalsa208sha256_ll( $passwd,       $passwdlen,      $salt,     $saltlen,  $0, $1, $r, $p, $buf,              $buflen)
    libsodium_raw._crypto_pwhash_scryptsalsa208sha256_ll( password_byte, password_leng,   salt_byte, salt_leng, N,  0,  r,  p,  data_byte.address, data_byte.length);
    free_all([password_byte, salt_byte]);
 
    return data_byte.extractBytes();
  }
  
  
  
  function crypto_pwhash_scryptsalsa208sha256(password, salt, opsLimit, memLimit, olen){
   
    var password_byte = injectBytes( encode_utf8(password) );
    var salt_byte     = injectBytes( encode_utf8(salt) );
    var password_leng = password.length;
    var salt_leng     = salt.length;
    var data_byte     = new Target( olen );

    //function    _crypto_pwhash_scryptsalsa208sha256   ( $out,           $0, $1, $passwd,              $2, $3, $salt,             $4, $5, $memlimit)
    //int          crypto_pwhash_scryptsalsa208sha256   (                out,    long long outlen,        passwd, long long passwdlen,      salt, long long opslimit, memlimit)
    libsodium_raw._crypto_pwhash_scryptsalsa208sha256   (  data_byte.address, data_byte.length, 0, password_byte,    password_leng, 0, salt_byte,        opsLimit, 0, memLimit)
    
    free_all([password_byte, salt_byte]);
 
    return data_byte.extractBytes();
  }


  //---------------------------------------------------------------------------

  exports.crypto_auth_BYTES             = libsodium_raw._crypto_auth_BYTES;
  exports.crypto_auth_KEYBYTES          = libsodium_raw._crypto_auth_KEYBYTES;
  exports.crypto_box_BEFORENMBYTES      = libsodium_raw._crypto_box_BEFORENMBYTES;
  exports.crypto_box_BOXZEROBYTES       = libsodium_raw._crypto_box_BOXZEROBYTES;
  exports.crypto_box_NONCEBYTES         = libsodium_raw._crypto_box_NONCEBYTES;
  exports.crypto_box_PUBLICKEYBYTES     = libsodium_raw._crypto_box_PUBLICKEYBYTES;
  exports.crypto_box_SECRETKEYBYTES     = libsodium_raw._crypto_box_SECRETKEYBYTES;
  exports.crypto_box_ZEROBYTES          = libsodium_raw._crypto_box_ZEROBYTES;
  exports.crypto_hash_BYTES             = libsodium_raw._crypto_hash_BYTES;
  exports.crypto_hash_sha256_BYTES      = libsodium_raw._crypto_hash_sha256_BYTES;
  exports.crypto_hashblocks_BLOCKBYTES  = libsodium_raw._crypto_hashblocks_BLOCKBYTES;
  exports.crypto_hashblocks_STATEBYTES  = libsodium_raw._crypto_hashblocks_STATEBYTES;
  exports.crypto_onetimeauth_BYTES      = libsodium_raw._crypto_onetimeauth_BYTES;
  exports.crypto_onetimeauth_KEYBYTES   = libsodium_raw._crypto_onetimeauth_KEYBYTES;
  exports.crypto_secretbox_BOXZEROBYTES = libsodium_raw._crypto_secretbox_BOXZEROBYTES;
  exports.crypto_secretbox_KEYBYTES     = libsodium_raw._crypto_secretbox_KEYBYTES;
  exports.crypto_secretbox_NONCEBYTES   = libsodium_raw._crypto_secretbox_NONCEBYTES;
  exports.crypto_secretbox_ZEROBYTES    = libsodium_raw._crypto_secretbox_ZEROBYTES;
  exports.crypto_sign_BYTES             = libsodium_raw._crypto_sign_BYTES;
  exports.crypto_sign_PUBLICKEYBYTES    = libsodium_raw._crypto_sign_PUBLICKEYBYTES;
  exports.crypto_sign_SECRETKEYBYTES    = libsodium_raw._crypto_sign_SECRETKEYBYTES;
  exports.crypto_stream_BEFORENMBYTES   = libsodium_raw._crypto_stream_BEFORENMBYTES;
  exports.crypto_stream_KEYBYTES        = libsodium_raw._crypto_stream_KEYBYTES;
  exports.crypto_stream_NONCEBYTES      = libsodium_raw._crypto_stream_NONCEBYTES;
  exports.crypto_scalarmult_SCALARBYTES = libsodium_raw._crypto_scalarmult_curve25519_SCALARBYTES;
  exports.crypto_scalarmult_BYTES       = libsodium_raw._crypto_scalarmult_curve25519_BYTES;

  exports.encode_utf8                   = encode_utf8;
  exports.encode_latin1                 = encode_latin1;
  exports.decode_utf8                   = decode_utf8;
  exports.decode_latin1                 = decode_latin1;
  exports.to_hex                        = to_hex;
  exports.from_hex                      = from_hex;

  exports.crypto_box_keypair            = crypto_box_keypair;
  exports.crypto_box_random_nonce       = crypto_box_random_nonce;
  exports.crypto_box                    = crypto_box;
  exports.crypto_box_open               = crypto_box_open;
  exports.crypto_box_precompute         = crypto_box_precompute;
  exports.crypto_box_precomputed        = crypto_box_precomputed;
  exports.crypto_box_open_precomputed   = crypto_box_open_precomputed;

  exports.crypto_stream_random_nonce    = crypto_stream_random_nonce;
  exports.crypto_stream                 = crypto_stream;
  exports.crypto_stream_xor             = crypto_stream_xor;

  exports.crypto_onetimeauth            = crypto_onetimeauth;
  exports.crypto_onetimeauth_verify     = crypto_onetimeauth_verify;

  exports.crypto_auth                   = crypto_auth;
  exports.crypto_auth_verify            = crypto_auth_verify;

  exports.crypto_secretbox_random_nonce = crypto_secretbox_random_nonce;
  exports.crypto_secretbox              = crypto_secretbox;
  exports.crypto_secretbox_open         = crypto_secretbox_open;

  exports.crypto_sign_keypair           = crypto_sign_keypair;
  exports.crypto_sign                   = crypto_sign;
  exports.crypto_sign_detached          = crypto_sign_detached;
  exports.crypto_sign_open              = crypto_sign_open;
  exports.crypto_sign_verify_detached   = crypto_sign_verify_detached;

  // CRYPTO PW HASH
  exports.crypto_scrypt_ll              = crypto_pwhash_scryptsalsa208sha256_ll;
  exports.crypto_scrypt                 = crypto_pwhash_scryptsalsa208sha256;

  // Crypto Hash
  exports.crypto_hash                   = crypto_hash;
  exports.crypto_hash_sha256            = crypto_hash_sha256;
  exports.crypto_hash_string            = crypto_hash_string;
  exports.crypto_generichash            = crypto_generichash;

  exports.crypto_sign_keypair_from_seed = crypto_sign_keypair_from_seed;
  exports.crypto_box_keypair_from_seed  = crypto_box_keypair_from_seed;
  exports.crypto_box_keypair_from_raw_sk = crypto_box_keypair_from_raw_sk;

  exports.crypto_scalarmult             = crypto_scalarmult;
  exports.crypto_scalarmult_base        = crypto_scalarmult_base;

  return exports;
})();
/*try {
                this['Module'] = Module;
                Module.test;
            } catch(e) {
                this['Module'] = Module = {};
            }
            Module['preRun'] = Module['preRun'] || [];
            Module['preRun'].push(function(){
                var randombyte = null;    
                try {
                    function randombyte_standard() {
                        var buf = new Int8Array(1);            
                        window.crypto.getRandomValues(buf);
                        return buf[0];
                    }
                    randombyte_standard();
                    randombyte = randombyte_standard;
                } catch (e) {
                    try {
                        var crypto = require('crypto');
                        function randombyte_node() {
                            return crypto.randomBytes(1)[0];
                        }
                        randombyte_node();
                        randombyte = randombyte_node;
                    } catch(e) { }
                }
                FS.init();
                var devFolder = FS.findObject('/dev') ||
                    Module['FS_createFolder']('/', 'dev', true, true);    
                Module['FS_createDevice'](devFolder, 'random', randombyte);
                Module['FS_createDevice'](devFolder, 'urandom', randombyte);    
            });*/

            libsodium.libsodium_raw = libsodium_raw;
            return libsodium;
        })( (typeof window !== 'undefined') ? window : null, (typeof document !== 'undefined') ? document : null );
    }
};

// export common.js module to allow one js file for browser and node.js
if ( typeof module !== 'undefined' && module.exports ) {
    module.exports = libsodium_factory;
}

